{
    "collab_server" : "",
    "contents" : "#######  Undocumented \"tpx\" utility functions #########\n\n## ** Only referenced from topics.R\n\n## check counts (can be an object from tm, slam, or a simple co-occurance matrix)\nCheckCounts <- function(counts){\n  if(class(counts)[1] == \"TermDocumentMatrix\"){ counts <- t(counts) }\n  if(is.null(dimnames(counts)[[1]])){ dimnames(counts)[[1]] <- paste(\"doc\",1:nrow(counts)) }\n  if(is.null(dimnames(counts)[[2]])){ dimnames(counts)[[2]] <- paste(\"wrd\",1:ncol(counts)) }\n  empty <- row_sums(counts) == 0\n  if(sum(empty) != 0){\n    counts <- counts[!empty,]\n    cat(paste(\"Removed\", sum(empty), \"blank documents.\\n\")) }\n  return(as.simple_triplet_matrix(counts))\n}\n\n## Topic estimation and selection for a list of K values\ntpxSelect <- function(X, K, bf, initheta, alpha, tol, kill, verb, nbundles,\n                      use_squarem, type, ind_model_indices, signatures, light, tmax, admix=TRUE, method_admix=1,\n                      sample_init=TRUE, grp=NULL, wtol=10^{-4}, qn=100,\n                      nonzero=FALSE, dcut=-10,\n                      top_genes=150, burn_in=5){\n\n  ## check grp if simple mixture\n  if(!admix){\n    if(is.null(grp) || length(grp)!=nrow(X)){  grp <- rep(1,nrow(X)) }\n    else{ grp <- factor(grp) }\n  }\n\n  ## return fit for single K\n  if(length(K)==1 && bf==FALSE){\n    if(verb){ cat(paste(\"Fitting the\",K,\"topic model.\\n\")) }\n    fit <-  tpxfit(X=X, theta=initheta, alpha=alpha, tol=tol, verb=verb,\n                   admix=admix, method_admix=method_admix, grp=grp, tmax=tmax, wtol=wtol, qn=qn,\n                   nbundles=nbundles, use_squarem, type=type, ind_model_indices = ind_model_indices,\n                   signatures=signatures, light = light,\n                   top_genes=top_genes, burn_in=burn_in)\n    fit$D <- tpxResids(X=X, theta=fit$theta, omega=fit$omega, grp=grp, nonzero=nonzero)$D\n    return(fit)\n  }\n\n  if(is.matrix(alpha)){ stop(\"Matrix alpha only works for fixed K\") }\n\n  if(verb){ cat(paste(\"Fit and Bayes Factor Estimation for K =\",K[1]))\n            if(length(K)>1){ cat(paste(\" ...\", max(K))) }\n            cat(\"\\n\") }\n\n  ## dimensions\n  n <- nrow(X)\n  p <- ncol(X)\n  nK <- length(K)\n\n  BF <- D <- NULL\n  iter <- 0\n\n  ## Null model log probability\n  sx <- sum(X)\n  qnull <- col_sums(X)/sx\n  null <- sum( X$v*log(qnull[X$j]) ) - 0.5*(n+p)*(log(sx) - log(2*pi))\n\n  ## allocate and initialize\n  best <- -Inf\n  bestfit <- NULL\n\n  ## loop over topic numbers\n  for(i in 1:nK){\n\n    ## Solve for map omega in NEF space\n    fit <- tpxfit(X=X, theta=initheta, alpha=alpha, tol=tol, verb=verb,\n                  admix=admix, method_admix=method_admix, grp=grp, tmax=tmax, wtol=wtol,\n                  qn=qn, nbundles=nbundles, use_squarem, type=type,\n                  ind_model_indices = ind_model_indices,\n                  signatures=signatures,\n                  light=light, top_genes=top_genes,\n                  burn_in = burn_in)\n\n    BF <- c(BF, tpxML(X=X, theta=fit$theta, omega=fit$omega, alpha=fit$alpha, L=fit$L, dcut=dcut,\n                      admix=admix, grp=grp) - null)\n    R <- tpxResids(X=X, theta=fit$theta, omega=fit$omega, grp=grp, nonzero=nonzero)\n    D <- cbind(D, unlist(R$D))\n\n    if(verb>0) cat(paste(\"log BF(\", K[i], \") =\", round(BF[i],2)))\n    if(verb>1) cat(paste(\" [ \", fit$iter,\"steps, disp =\",round(D[1,i],2),\" ]\\n\")) else if(verb >0) cat(\"\\n\")\n\n    if(is.nan(BF[i]) | is.na(BF[i])){\n      cat(\"NAN for Bayes factor.\\n\")\n      return(list(theta=fit$theta, omega=fit$omega, alpha=fit$alpha,\n                  BF=BF, D=D, K=K))\n   #   return(bestfit)\n    }\n\n    else{\n          if(BF[i] > best){ # check for a new \"best\" topic\n          best <- BF[i]\n          bestfit <- fit\n          } else if(kill>0 && i>kill){ # break after kill consecutive drops\n          if(prod(BF[i-0:(kill-1)] < BF[i-1:kill])==1) break }\n\n          if(i<nK){\n              if(!admix){ initheta <- tpxinit(X,2,K[i+1], alpha, 0) }\n              else{ initheta <- tpxThetaStart(X, fit$theta, fit$omega, K[i+1]) }\n          }\n    names(BF) <- dimnames(D)[[2]] <- paste(K[1:length(BF)])\n    return(list(theta=bestfit$theta, omega=bestfit$omega, alpha=bestfit$alpha,\n              BF=BF, D=D, K=K))\n    }\n  }\n}\n\n## theta initialization\ntpxinit <- function(X, initheta, K1, alpha, verb, nbundles=1,\n                    use_squarem=FALSE, init.adapt){\n## initheta can be matrix, or c(nK, tmax, tol, verb)\n\n  if(is.matrix(initheta)){\n    if(ncol(initheta)!=K1){ stop(\"mis-match between initheta and K.\") }\n    if(prod(initheta>0) != 1){ stop(\"use probs > 0 for initheta.\") }\n    return(normalizetpx(initheta, byrow=FALSE)) }\n\n  if(is.matrix(alpha)){\n    if(nrow(alpha)!=ncol(X) || ncol(alpha)!=K1){ stop(\"bad matrix alpha dimensions; check your K\") }\n    return(normalizetpx(alpha, byrow=FALSE)) }\n\n  if(is.null(initheta)){ ilength <- K1-1 }else{ ilength <- initheta[1] }\n  if(ilength < 1){ ilength <- 1 }\n\n  ## set number of initial steps\n  if(length(initheta)>1){ tmax <- initheta[2] }else{ tmax <- 3 }\n  ## set the tolerance\n  if(length(initheta)>2){ tol <- initheta[3] }else{ tol <- 0.5 }\n  ## print option\n  if(length(initheta)>3){ verb <- initheta[4] }else{ verb <- 0 }\n\n\n  if(verb){ cat(\"Building initial topics\")\n            if(verb > 1){ cat(\" for K = \") }\n            else{ cat(\"... \") } }\n\n  nK <- length( Kseq <-  unique(ceiling(seq(2,K1,length=ilength))) )\n\n  if(!init.adapt){\n  initheta <- tpxThetaStart(X, matrix(col_sums(X)/sum(X), ncol=1), matrix(rep(1,nrow(X))), K1)\n#  return(initheta)\n  } else{\n  initheta <- tpxThetaStart(X, matrix(col_sums(X)/sum(X), ncol=1), matrix(rep(1,nrow(X))), 2)\n\n  if(verb > 0)\n    { cat(\"\\n\")\n      print(list(Kseq=Kseq, tmax=tmax, tol=tol)) }\n\n  ## loop over topic numbers\n  for(i in 1:nK){\n\n    ## Solve for map omega in NEF space\n    fit <- tpxfit(X=X, theta=initheta, alpha=alpha, tol=tol, verb=verb,\n                  admix=TRUE, method_admix=1, grp=NULL, tmax=tmax, wtol=-1, qn=-1,\n                  nbundles = nbundles, type=\"full\", signatures=signatures,\n                  use_squarem = FALSE, light=FALSE)\n    if(verb>1){ cat(paste(Kseq[i],\",\", sep=\"\")) }\n\n    if(i<nK){ initheta <- tpxThetaStart(X, fit$theta, fit$omega, Kseq[i+1]) }else{ initheta <- fit$theta }\n  }\n  if(verb){ cat(\"done.\\n\") }\n#  return(initheta)\n  }\n  return(initheta)\n}\n\n## ** main workhorse function.  Only Called by the above wrappers.\n## topic estimation for a given number of topics (taken as ncol(theta))\ntpxfit <- function(X, theta, alpha, tol, verb,\n                   admix, method_admix, grp, tmax, wtol, qn, nbundles,\n                   use_squarem, type, ind_model_indices, signatures, light,\n                   top_genes, burn_in)\n{\n  ## inputs and dimensions\n  if(!inherits(X,\"simple_triplet_matrix\")){ stop(\"X needs to be a simple_triplet_matrix\") }\n  K <- ncol(theta)\n  n <- nrow(X)\n  p <- ncol(X)\n  m <- row_sums(X)\n  if(is.null(alpha)){ alpha <- 1/(K*p) }\n  if(is.matrix(alpha)){ if(nrow(alpha)!=p || ncol(alpha)!=K){ stop(\"bad matrix alpha dimensions\") }}\n\n  ## recycle these in tpcweights to save time\n  xvo <- X$v[order(X$i)]\n  wrd <- X$j[order(X$i)]-1\n  doc <- c(0,cumsum(as.double(table(factor(X$i, levels=c(1:nrow(X)))))))\n\n  ## Initialize\n  system.time(omega <- tpxweights(n=n, p=p, xvo=xvo, wrd=wrd, doc=doc, start=tpxOmegaStart(X,theta), theta=theta))\n  if(!admix){ omega <- matrix(apply(omega,2, function(w) tapply(w,grp,mean)), ncol=K) }\n\n  ## tracking\n  iter <- 0\n  dif <- tol+1+qn\n  update <- TRUE\n  if(verb>0){\n    cat(\"log posterior increase: \" )\n    digits <- max(1, -floor(log(tol, base=10))) }\n\n  Y <- NULL # only used for qn > 0\n  Q0 <- col_sums(X)/sum(X)\n  L <- tpxlpost(X=X, theta=theta, omega=omega, alpha=alpha, admix=admix, grp=grp)\n  if(is.infinite(L)){ L <- sum( (log(Q0)*col_sums(X))[Q0>0] ) }\n\n  iter <- 1;\n\n  ## Iterate towards MAP\n  while( update  && iter < tmax ){\n\n    if(light==2){\n    if(admix && wtol > 0 && (iter-1)%%nbundles==0){\n      if(iter <= burn_in){\n        Wfit <- tpxweights(n=nrow(X), p=ncol(X), xvo=xvo, wrd=wrd, doc=doc,\n                           start=omega, theta=theta,  verb=0, nef=TRUE, wtol=wtol, tmax=20)\n      }\n      if(iter > burn_in){\n       # system.time(suppressWarnings(select_genes <- as.numeric(na.omit(as.vector(ExtractTopFeatures(theta, top_genes))))))\n         ptm <- proc.time()\n\n        topic_index <- apply(theta,1, which.max);\n        select_genes <- vector();\n        for(k in 1:K){\n          topic_labels <- which(topic_index==k);\n          select_genes <- c(select_genes,\n                            topic_labels[order(apply(theta[which(topic_index==k),],1, sd),\n                                decreasing=TRUE)[1:round(min(top_genes,(length(topic_labels)*0.9)))]]);\n        }\n        select_genes <- as.numeric(select_genes);\n\n        counts <- as.matrix(X);\n        counts.mod <- counts[,select_genes];\n        Xmod <- CheckCounts(counts.mod)\n        xvo2 <- Xmod$v[order(Xmod$i)]\n        wrd2 <- Xmod$j[order(Xmod$i)]-1\n        doc2 <- c(0,cumsum(as.double(table(factor(Xmod$i, levels=c(1:nrow(Xmod)))))))\n\n        if(length(which(rowSums(counts.mod)==0))==0){\n          Wfit <- tpxweights(n=nrow(Xmod), p=ncol(Xmod), xvo=xvo2, wrd=wrd2, doc=doc2,\n                             start=omega, theta=theta[select_genes,],  verb=0, nef=TRUE, wtol=wtol, tmax=20)\n        }else{\n          Wfit <- matrix(0, nrow=nrow(X), ncol=ncol(X));\n          Wfit[which(rowSums(counts.mod)==0),] <- omega[which(rowSums(counts.mod)==0),];\n          Wfit[which(rowSums(counts.mod)!=0),] <- tpxweights(n=nrow(Xmod), p=ncol(Xmod), xvo=xvo2, wrd=wrd2, doc=doc2,\n                                                             start=omega, theta=theta[select_genes,],  verb=0, nef=TRUE, wtol=wtol, tmax=20)\n        }\n\n        proc.time() - ptm\n      }\n    }else{\n      Wfit <- omega;\n    }}\n\n    if(light==1){\n    if(admix && wtol > 0 && (iter-1)%%nbundles==0){\n      Wfit <- tpxweights(n=nrow(X), p=ncol(X), xvo=xvo, wrd=wrd, doc=doc,\n                      start=omega, theta=theta,  verb=0, nef=TRUE, wtol=wtol, tmax=20)\n    }else{\n      Wfit <- omega;\n    }}\n\n    if(light==0){\n      Wfit <- omega;\n    }\n\n\n    ## sequential quadratic programming for conditional Y solution\n#     if(admix && wtol > 0 && (iter-1)%%nbundles==0)\n     ##if(admix && wtol > 0)\n#      { Wfit <- tpxweights(n=nrow(Xmod), p=ncol(X), xvo=xvo, wrd=wrd, doc=doc,\n#        start=omega, theta=theta,  verb=0, nef=TRUE, wtol=wtol, tmax=20) }else{ Wfit <- omega }\n\n\n#    move2 <- tpxEM(X=X, m=m, theta=theta, omega=Wfit, alpha=alpha, admix=admix,\n#                   method_admix=1, grp=grp)\n\n    ## squarem acceleration\n\n    if(use_squarem){\n\n    Wfit <- normalizetpx(Wfit + 1e-15, byrow=TRUE);\n    theta <- normalizetpx(theta + 1e-15, byrow=FALSE);\n    param_vec_in <- c(as.vector(logit(Wfit)),as.vector(logit(theta)));\n  #  param_vec_in <- c(as.vector(omega),as.vector(theta));\n    res <- squarem(par=as.numeric(param_vec_in),\n                   fixptfn=tpxsquarEM,\n                   objfn= tpxlpost_squarem,\n                   X=X,\n                   m=m,\n                   K=K,\n                   alpha=alpha,\n                   admix=admix,\n                   method_admix=method_admix,\n                   grp=grp,\n                   control=list(maxiter = 5, trace = FALSE, square=TRUE, tol=1e-10));\n\n    res_omega <- inv.logit(matrix(res$par[1:(nrow(X)*K)], nrow=nrow(X), ncol=K));\n   #  res_omega <- matrix(res$par[1:(nrow(X)*K)], nrow=nrow(X), ncol=K);\n    res_theta <- inv.logit(matrix(res$par[-(1:(nrow(X)*K))], nrow=ncol(X), ncol=K));\n   #  res_theta <- matrix(res$par[-(1:(nrow(X)*K))], nrow=ncol(X), ncol=K);\n\n    move <- list(\"omega\"=res_omega, \"theta\"=res_theta);\n    QNup <- list(\"omega\"=move$omega, \"theta\"=move$theta, \"L\"=res$value.objfn, \"Y\"=NULL)\n    if(type==\"independent\"){\n      out <-  tpxThetaGroupInd(QNup$theta, ind_model_indices, signatures)\n      QNup$theta <-out$theta;\n    }\n  }\n\n    if(!use_squarem){\n    ## joint parameter EM update\n    Wfit <- normalizetpx(Wfit + 1e-15, byrow=TRUE);\n    theta <- normalizetpx(theta + 1e-15, byrow=FALSE);\n    move <- tpxEM(X=X, m=m, theta=theta, omega=Wfit, alpha=alpha, admix=admix,\n                  method_admix=method_admix, grp=grp)\n  #  L_new <- tpxlpost(X=X, theta=move$theta, omega=move$omega, alpha=alpha, admix=admix, grp=grp)\n  #  QNup <- list(\"move\"=move, \"L\"=L_new, \"Y\"=NULL)\n    ## quasinewton-newton acceleration\n    QNup <- tpxQN(move=move, Y=Y, X=X, alpha=alpha, verb=verb, admix=admix, grp=grp, doqn=qn-dif)\n    if(type==\"independent\"){\n      out <-  tpxThetaGroupInd(move$theta, ind_model_indices, signatures)\n      move$theta <-out$theta;\n    }\n    move <- QNup$move\n    Y <- QNup$Y\n  }\n\n\n    if(QNup$L < L){  # happens on bad Wfit, so fully reverse\n      if(verb > 10){ cat(\"_reversing a step_\") }\n      move <- tpxEM(X=X, m=m, theta=theta, omega=omega, alpha=alpha, admix=admix,\n                    method_admix=method_admix,grp=grp)\n      if(type==\"independent\"){\n        out <-  tpxThetaGroupInd(move$theta, ind_model_indices, signatures)\n        move$theta <-out$theta;\n      }\n      QNup$L <-  tpxlpost(X=X, theta=move$theta, omega=move$omega, alpha=alpha, admix=admix, grp=grp) }\n\n    ## calculate dif\n    dif <- (QNup$L-L)\n\n    L <- QNup$L\n\n\n    ## check convergence\n    if(abs(dif) < tol){\n      if(sum(abs(theta-move$theta)) < tol){ update = FALSE } }\n\n    ## print\n    if(verb>0 && (iter-1)%%ceiling(10/verb)==0 && iter>0){\n    ##if(verb>0 && iter>0){\n      cat( paste( round(dif,digits), #\" (\", sum(abs(theta-move$theta)),\")\",\n                 \", \", sep=\"\") ) }\n\n    ## heartbeat for long jobs\n    if(((iter+1)%%1000)==0){\n          cat(sprintf(\"p %d iter %d diff %g\\n\",\n                nrow(theta), iter+1,round(dif))) }\n\n    ## iterate\n    iter <- iter+1\n    theta <- move$theta\n    omega <- move$omega\n\n  }\n\n  ## final log posterior\n  L <- tpxlpost(X=X, theta=theta, omega=omega, alpha=alpha, admix=admix, grp=grp)\n\n  ## summary print\n  if(verb>0){\n    cat(\"done.\")\n    if(verb>1) { cat(paste(\" (L = \", round(L,digits), \")\", sep=\"\")) }\n    cat(\"\\n\")\n  }\n\n  out <- list(theta=theta, omega=omega, K=K, alpha=alpha, L=L, iter=iter)\n  invisible(out) }\n\n\n## ** called from topics.R (predict) and tpx.R\n## Conditional solution for topic weights given theta\ntpxweights <- function(n, p, xvo, wrd, doc, start, theta, verb=FALSE, nef=TRUE, wtol=10^{-5}, tmax=1000)\n{\n  K <- ncol(theta)\n  start[start == 0] <- 0.1/K\n  start <- start/rowSums(start)\n  omega <- .C(\"Romega\",\n              n = as.integer(n),\n              p = as.integer(p),\n              K = as.integer(K),\n              doc = as.integer(doc),\n              wrd = as.integer(wrd),\n              X = as.double(xvo),\n              theta = as.double(theta),\n              W = as.double(t(start)),\n              nef = as.integer(nef),\n              tol = as.double(wtol),\n              tmax = as.integer(tmax),\n              verb = as.integer(verb),\n              PACKAGE=\"maptpx\")\n  return(t(matrix(omega$W, nrow=ncol(theta), ncol=n))) }\n\n## ** Called only in tpx.R\n\ntpxsquarEM <- function(param_vec_in, X, m, K,\n                       alpha, admix, method_admix, grp){\n omega_in <- inv.logit(matrix(param_vec_in[1:(nrow(X)*K)], nrow=nrow(X), ncol=K));\n#  omega_in <- matrix(param_vec_in[1:(nrow(X)*K)], nrow=nrow(X), ncol=K);\n theta_in <- inv.logit(matrix(param_vec_in[-(1:(nrow(X)*K))], nrow=ncol(X), ncol=K))\n#  theta_in <- matrix(param_vec_in[-(1:(nrow(X)*K))], nrow=ncol(X), ncol=K);\n out <- tpxEM(X, m, theta_in, omega_in, alpha, admix, method_admix, grp);\n param_vec_out <- c(as.vector(logit(out$omega)),as.vector(logit(out$theta)))\n# param_vec_out <- c(as.vector(out$omega),as.vector(out$theta))\n return(param_vec_out)\n}\n\n## single EM update. two versions: admix and mix\ntpxEM <- function(X, m, theta, omega, alpha, admix, method_admix, grp)\n{\n  n <- nrow(X)\n  p <- ncol(X)\n  K <- ncol(theta)\n\n  if(admix==TRUE & method_admix==1){\n\n    lambda <- omega%*%t(theta);\n    counts2 <- as.matrix(X);\n    temp <- counts2/lambda;\n    t_matrix <- (t(temp) %*% omega)*theta;\n    w_matrix <- (temp %*% theta)*omega;\n\n    theta <- normalizetpx(t_matrix+alpha, byrow=FALSE)\n    omega <- normalizetpx(w_matrix+(1/(n*K)), byrow=TRUE)\n    full_indices <- which(omega==1, arr.ind=T)\n    full_indices_rows <- unique(full_indices[,1]);\n    omega[full_indices_rows,] <- omega[full_indices_rows,] + (1/(n*K));\n    omega <- normalizetpx(omega, byrow=TRUE)\n  }\n\n  if(admix==TRUE & method_admix==2){ Xhat <- (X$v/tpxQ(theta=theta, omega=omega, doc=X$i, wrd=X$j))*(omega[X$i,]*theta[X$j,])\n             Zhat <- .C(\"Rzhat\", n=as.integer(n), p=as.integer(p), K=as.integer(K), N=as.integer(nrow(Xhat)),\n                         Xhat=as.double(Xhat), doc=as.integer(X$i-1), wrd=as.integer(X$j-1),\n                        zj = as.double(rep(0,K*p)), zi = as.double(rep(0,K*n)), PACKAGE=\"maptpx\")\n             theta <- normalizetpx(matrix(Zhat$zj+alpha, ncol=K), byrow=FALSE)\n             omega <- normalizetpx(matrix(Zhat$zi+1/K, ncol=K)) }\n  if(!admix){\n    qhat <- tpxMixQ(X, omega, theta, grp, qhat=TRUE)$qhat\n    ## EM update\n    theta <- normalizetpx(tcrossprod_simple_triplet_matrix( t(X), t(qhat) ) + alpha, byrow=FALSE)\n    omega <- normalizetpx(matrix(apply(qhat*m,2, function(x) tapply(x,grp,sum)), ncol=K)+1/K )  }\n\n  return(list(theta=theta, omega=omega)) }\n\n## Quasi Newton update for q>0\ntpxQN <- function(move, Y, X, alpha, verb, admix, grp, doqn)\n{\n  move$theta[move$theta==1] <- 1 - 1e-14;\n  move$omega[move$omega==1] <- 1 - 1e-14;\n  move$omega[move$omega==0] <- 1e-14;\n  move$theta[move$theta==0] <- 1e-14;\n  move$theta <- normalizetpx(move$theta, byrow = FALSE)\n  move$omega <- normalizetpx(move$omega, byrow = TRUE)\n\n  ## always check likelihood\n  L <- tpxlpost(X=X, theta=move$theta, omega=move$omega,\n                alpha=alpha, admix=admix, grp=grp)\n\n  if(doqn < 0){ return(list(move=move, L=L, Y=Y)) }\n\n  ## update Y accounting\n  Y <- cbind(Y, tpxToNEF(theta=move$theta, omega=move$omega))\n  if(ncol(Y) < 3){ return(list(Y=Y, move=move, L=L)) }\n  if(ncol(Y) > 3){ warning(\"mis-specification in quasi-newton update; please report this bug.\") }\n\n  ## Check quasinewton secant conditions and solve F(x) - x = 0.\n  U <- as.matrix(Y[,2]-Y[,1])\n  V <- as.matrix(Y[,3]-Y[,2])\n  sUU <- sum(U^2)\n  sVU <- sum(V*U)\n  Ynew <- Y[,3] + V*(sVU/(sUU-sVU))\n  qnup <- tpxFromNEF(Ynew, n=nrow(move$omega),\n                     p=nrow(move$theta), K=ncol(move$theta))\n\n  ## check for a likelihood improvement\n  Lqnup <- try(tpxlpost(X=X, theta=qnup$theta, omega=qnup$omega,\n                        alpha=alpha, admix=admix, grp=grp), silent=TRUE)\n\n  if(inherits(Lqnup, \"try-error\")){\n    if(verb>10){ cat(\"(QN: try error) \") }\n    return(list(Y=Y[,-1], move=move, L=L)) }\n\n  if(verb>10){ cat(paste(\"(QN diff \", round(Lqnup-L,3), \")\\n\", sep=\"\")) }\n\n  if(Lqnup < L){\n    return(list(Y=Y[,-1], move=move, L=L)) }\n  else{\n    L <- Lqnup\n    Y <- cbind(Y[,2],Ynew)\n    return( list(Y=Y, move=qnup, L=L) )\n  }\n}\n\ntpxlpost_squarem <- function(param_vec_in,  X, m, K,\n                             alpha, admix=TRUE, method_admix, grp=NULL)\n{\n  omega_in <- inv.logit(matrix(param_vec_in[1:(nrow(X)*K)], nrow=nrow(X), ncol=K));\n#  omega_in <- matrix(param_vec_in[1:(nrow(X)*K)], nrow=nrow(X), ncol=K);\n  theta_in <- inv.logit(matrix(param_vec_in[-(1:(nrow(X)*K))], nrow=ncol(X), ncol=K))\n#  theta_in <- matrix(param_vec_in[-(1:(nrow(X)*K))], nrow=ncol(X), ncol=K);\n  return(tpxlpost(X, theta_in, omega_in, alpha, admix, grp))\n}\n\n\n## unnormalized log posterior (objective function)\ntpxlpost <- function(X, theta, omega, alpha, admix=TRUE, grp=NULL)\n{\n  theta[theta==1] <- 1 - 1e-10;\n  omega[omega==1] <- 1 - 1e-10;\n  omega[omega==0] <- 1e-10;\n  theta[theta==0] <- 1e-10;\n  theta <- normalizetpx(theta, byrow = FALSE)\n  omega <- normalizetpx(omega, byrow = TRUE)\n  if(!inherits(X,\"simple_triplet_matrix\")){ stop(\"X needs to be a simple_triplet_matrix.\") }\n  K <- ncol(theta)\n\n  if(admix){ L <- sum( X$v*log(tpxQ(theta=theta, omega=omega, doc=X$i, wrd=X$j)) ) }\n  else{ L <- sum(tpxMixQ(X, omega, theta, grp)$lqlhd) }\n  if(is.null(nrow(alpha))){ if(alpha != 0){ L <- L + sum(alpha*log(theta))  } } # unnormalized prior\n  L <- L + sum(log(omega))/K\n\n  return(L) }\n\n## log marginal likelihood\ntpxML <- function(X, theta, omega, alpha, L, dcut, admix=TRUE, grp=NULL){\n  ## get the indices\n  K <- ncol(theta)\n  p <- nrow(theta)\n  n <- nrow(omega)\n\n  theta[theta==1] <- 1 - 1e-14;\n  theta[theta==0] <- 1e-14;\n  theta <- normalizetpx(theta, byrow = FALSE)\n\n  omega[omega==1] <- 1 - 1e-14;\n  omega[omega==0] <- 1e-14;\n  omega <- normalizetpx(omega, byrow = TRUE)\n\n\n  ## return BIC for simple finite mixture model\n  if(!admix){\n    qhat <- tpxMixQ(X, omega, theta, grp, qhat=TRUE)$qhat\n    ML <- sum(X$v*log(row_sums(qhat[X$i,]*theta[X$j,])))\n    return( ML - 0.5*( K*p + (K-1)*n )*log(sum(X)) ) }\n\n  ML <- L  + lfactorial(K) # lhd multiplied by label switching modes\n\n  ## block-diagonal approx to determinant of the negative log hessian matrix\n  q <- tpxQ(theta=theta, omega=omega, doc=X$i, wrd=X$j)\n  D <- tpxHnegDet(X=X, q=q, theta=theta, omega=omega, alpha=alpha)\n\n  D[D < dcut] <- dcut\n  ML <- ML - 0.5*sum( D  )   # -1/2 |-H|\n\n  ML <- ML + (K*p + sum(omega>0.01))*log(2*pi)/2  # (d/2)log(2pi)\n  if(is.null(nrow(alpha))){ # theta prior normalizing constant\n    ML <- ML + K*( lgamma(p*(alpha+1)) - p*lgamma(alpha+1) )  }\n  else{ ML <- ML + sum(lgamma(col_sums(alpha+1)) - col_sums(lgamma(alpha+1))) } # matrix version\n  ## omega(phi) prior normalizing constant number of parameters\n  ML <- ML +  sum(D[-(1:p)]>dcut)*( lfactorial(K) - K*lgamma( 1+1/K ) ) #\n\n  return(ML) }\n\n## find residuals for X$v\ntpxResids <- function(X, theta, omega, grp=NULL, nonzero=TRUE)\n{\n  if(!inherits(X,\"simple_triplet_matrix\")){ stop(\"X needs to be a simple_triplet_matrix.\") }\n\n  m <- row_sums(X)\n  K <- ncol(theta)\n  n <- nrow(X)\n  phat <- sum(col_sums(X)>0)\n  d <- n*(K-1) + K*( phat-1 )\n\n  if(nrow(omega) == nrow(X)){\n    qhat <- tpxQ(theta=theta, omega=omega, doc=X$i, wrd=X$j)\n    xhat <- qhat*m[X$i]\n  } else{\n    q <- tpxMixQ(X=X, omega=omega, theta=theta, grp=grp, qhat=TRUE)$qhat\n    qhat <- row_sums(q[X$i,]*theta[X$j,])\n    xhat <- qhat*m[X$i] }\n\n  if(nonzero || nrow(omega) < nrow(X)){\n    ## Calculations based on nonzero counts\n    ## conditional adjusted residuals\n    e <- X$v^2 - 2*(X$v*xhat - xhat^2)\n    s <- qhat*m[X$i]*(1-qhat)^{1-m[X$i]}\n    r <- sqrt(e/s)\n    df <- length(r)*(1-d/(n*phat))\n    R <- sum(r^2)\n  }\n  else{\n    ## full table calculations\n    e <- (X$v^2 - 2*X$v*m[X$i]*qhat)\n    s <- m[X$i]*qhat*(1-qhat)\n    fulltable <- .C(\"RcalcTau\",\n                 n = as.integer(nrow(omega)),\n                 p = as.integer(nrow(theta)),\n                 K = as.integer(ncol(theta)),\n                 m = as.double(m),\n                 omega = as.double(omega),\n                 theta = as.double(theta),\n                 tau = double(1), size=double(1),\n                 PACKAGE=\"maptpx\" )\n    tau <- fulltable$tau\n    R <- sum(e/s) + tau\n    df <-  fulltable$size - phat  - d\n    r <- suppressWarnings(sqrt(e/s + tau))\n    r[is.nan(r)] <- 0 ## should not happen, but can theoretically\n  }\n\n  ## collect and output\n  sig2 <- R/df\n  rho <- suppressWarnings(pchisq(R, df=df, lower.tail=FALSE))\n  D <- list(dispersion=sig2, pvalue=rho, df=df)\n  return( list(s=s, e=e, r=r, D=D) ) }\n\n\n## fast initialization functions for theta (after increasing K) and omega (given theta)\ntpxThetaStart <- function(X, theta, omega, K)\n  {\n    R <- tpxResids(X, theta=theta, omega=omega, nonzero=TRUE)\n    X$v <- R$e*(R$r>3) + 1/ncol(X)\n    Kpast <- ncol(theta)\n    Kdiff <- K-Kpast\n    if(Kpast != ncol(omega) || Kpast >= K){ stop(\"bad K in tpxThetaStart\") }\n    initheta <- normalizetpx(Kpast*theta+rowMeans(theta), byrow=FALSE)\n    n <- nrow(X)\n    ki <- matrix(1:(n-n%%Kdiff), ncol=Kdiff)\n    for(i in 1:Kdiff){ initheta <- cbind(initheta, (col_sums(X[ki[,i],])+1/ncol(X))/(sum(X[ki[,i],])+1)) }\n    return( initheta )\n  }\n\ntpxOmegaStart <- function(X, theta)\n  {\n    if(!inherits(X,\"simple_triplet_matrix\")){ stop(\"X needs to be a simple_triplet_matrix.\") }\n    omega <- try(tcrossprod_simple_triplet_matrix(X, solve(t(theta)%*%theta)%*%t(theta)), silent=TRUE )\n    if(inherits(omega,\"try-error\")){ return( matrix( 1/ncol(theta), nrow=nrow(X), ncol=ncol(theta) ) ) }\n    omega[omega <= 0] <- .5\n    return( normalizetpx(omega, byrow=TRUE) )\n  }\n\n\n## fast computation of sparse P(X) for X>0\ntpxQ <- function(theta, omega, doc, wrd){\n\n  theta[theta==1] <- 1 - 1e-14;\n  theta[theta==0] <- 1e-14;\n  theta <- normalizetpx(theta, byrow = FALSE)\n\n  omega[omega==1] <- 1 - 1e-14;\n  omega[omega==0] <- 1e-14;\n  omega <- normalizetpx(omega, byrow = TRUE)\n\n  if(length(wrd)!=length(doc)){stop(\"index mis-match in tpxQ\") }\n  if(ncol(omega)!=ncol(theta)){stop(\"theta/omega mis-match in tpxQ\") }\n\n  out <- .C(\"RcalcQ\",\n            n = as.integer(nrow(omega)),\n            p = as.integer(nrow(theta)),\n            K = as.integer(ncol(theta)),\n            doc = as.integer(doc-1),\n            wrd = as.integer(wrd-1),\n            N = as.integer(length(wrd)),\n            omega = as.double(omega),\n            theta = as.double(theta),\n            q = double(length(wrd)),\n            PACKAGE=\"maptpx\" )\n\n  return( out$q ) }\n\n## model and component likelihoods for mixture model\ntpxMixQ <- function(X, omega, theta, grp=NULL, qhat=FALSE){\n  if(is.null(grp)){ grp <- rep(1, nrow(X)) }\n\n  theta[theta==1] <- 1 - 1e-14;\n  theta[theta==0] <- 1e-14;\n  theta <- normalizetpx(theta, byrow = FALSE)\n\n  omega[omega==1] <- 1 - 1e-14;\n  omega[omega==0] <- 1e-14;\n  omega <- normalizetpx(omega, byrow = TRUE)\n\n  K <- ncol(omega)\n  n <- nrow(X)\n  mixhat <- .C(\"RmixQ\",\n               n = as.integer(nrow(X)),\n               p = as.integer(ncol(X)),\n               K = as.integer(K),\n               N = as.integer(length(X$v)),\n               B = as.integer(nrow(omega)),\n               cnt = as.double(X$v),\n               doc = as.integer(X$i-1),\n               wrd = as.integer(X$j-1),\n               grp = as.integer(as.numeric(grp)-1),\n               omega = as.double(omega),\n               theta = as.double(theta),\n               Q = double(K*n),\n               PACKAGE=\"maptpx\")\n  ## model and component likelihoods\n  lQ <- matrix(mixhat$Q, ncol=K)\n  lqlhd <- log(row_sums(exp(lQ)))\n  lqlhd[is.infinite(lqlhd)] <- -600 # remove infs\n  if(qhat){\n    qhat <- exp(lQ-lqlhd)\n    ## deal with numerical overload\n    infq <- row_sums(qhat) < .999\n    if(sum(infq)>0){\n      qhat[infq,] <- 0\n      qhat[n*(apply(matrix(lQ[infq,],ncol=K),1,which.max)-1) + (1:n)[infq]] <- 1 }\n  }\n  return(list(lQ=lQ, lqlhd=lqlhd, qhat=qhat)) }\n\n## negative log hessian block diagonal matrix for theta & omega\ntpxHnegDet <- function(X, q, theta, omega, alpha){\n  K <- ncol(theta)\n  n <- nrow(omega)\n\n  ## sparse Xij/Qij^2\n  Xq <- X\n  Xq$v <- Xq$v/q^2\n\n  ## negative 2nd derivitive matrices for theta\n  HT <- tcrossprod_simple_triplet_matrix(t(Xq), apply(omega, 1, function(v) v%o%v ) )\n  HT[,K*(0:(K-1))+1:K] <- HT[,K*(0:(K-1))+1:K] + alpha/theta^2 # will break for alpha<=1\n  DT <- apply(HT, 1, tpxlogdet)\n\n  ## ditto for omega\n  HW <- matrix(.C(\"RnegHW\",\n                  n = as.integer(nrow(omega)),\n                  p = as.integer(nrow(theta)),\n                  K = as.integer(K-1),\n                  omeg = as.double(omega[,-1]),\n                  thet = as.double(theta[,-1]),\n                  doc = as.integer(X$i-1),\n                  wrd = as.integer(X$j-1),\n                  cnt = as.double(X$v),\n                  q = as.double(q),\n                  N = as.integer(length(q)),\n                  H = double(n*(K-1)^2),\n                  PACKAGE=\"maptpx\")$H,\n               nrow=(K-1)^2, ncol=n)\n  DW <- apply(HW, 2, tpxlogdet)\n  return( c(DT,DW) )  }\n\n## functions to move theta/omega to and from NEF.\ntpxToNEF <- function(theta, omega){\n  n <- nrow(omega)\n  p <- nrow(theta)\n  K <- ncol(omega)\n  return(.C(\"RtoNEF\",\n            n=as.integer(n), p=as.integer(p), K=as.integer(K),\n            Y=double((p-1)*K + n*(K-1)),\n            theta=as.double(theta), tomega=as.double(t(omega)),\n            PACKAGE=\"maptpx\")$Y)\n}\n\n## 'From' NEF representation back to probabilities\ntpxFromNEF <- function(Y, n, p, K){\n  bck <- .C(\"RfromNEF\",\n            n=as.integer(n), p=as.integer(p), K=as.integer(K),\n            Y=as.double(Y), theta=double(K*p), tomega=double(K*n),\n            PACKAGE=\"maptpx\")\n  return(list(omega=t( matrix(bck$tomega, nrow=K) ), theta=matrix(bck$theta, ncol=K)))\n}\n\n## utility log determinant function for speed/stabilty\ntpxlogdet <- function(v){\n    v <- matrix(v, ncol=sqrt(length(v)))\n    if( sum(zeros <- colSums(v)==0)!=0 ){\n      cat(\"warning: boundary values in laplace approx\\n\")\n      v <- v[-zeros,-zeros] }\n\n    return(determinant(v, logarithm=TRUE)$modulus)\n}\n\ntpxThetaGroupInd <- function(theta_old, ind_model_indices, signatures){\n  if(dim(signatures)[1] != length(ind_model_indices)){\n    stop(\"the number of possible signatures must match with the number of independence indices provided\")\n  }\n  if(length(ind_model_indices) < dim(theta_old)[1]){\n    theta1 <- theta_old[-ind_model_indices,]\n  }\n  theta <- theta_old[ind_model_indices, ]\n  theta <- apply(theta, 2, function(x) return(x/sum(x)))\n  new_theta <- matrix(0, dim(theta)[1], dim(theta)[2])\n  sig_list <- list()\n  for(k in 1:dim(theta)[2]){\n    num_unique_sigs <- list()\n    for(l in 1:dim(signatures)[2]){\n      sig_list[[l]] <- tapply(theta[,k], factor(signatures[,l], levels=unique(signatures[,l])), sum)\n      num_unique_sigs[[l]] <- 0:(length(unique(signatures[,l]))-1)\n     # num_unique_sigs[[l]] <- 0:(max(signatures[,l])-1)\n      if(l==1){\n        f_array <- sig_list[[l]]\n      }else{\n        f_array <- outer(f_array, sig_list[[l]])\n      }\n    }\n    signature_new <- as.numeric();\n    vec <- numeric()\n    grid <- expand.grid(num_unique_sigs)\n    colnames(grid) <- colnames(signatures)\n#\n#     for(x in 1:dim(grid)[1])\n#     {\n#       out <- f_array[matrix(as.numeric(grid[x,])+1,1)]\n#     }\n    vec <- apply(grid, 1, function(x) return(f_array[matrix(as.numeric(x)+1,1)]))\n\n    a1.vec <- apply(signatures, 1, paste, collapse = \"\")\n    a2.vec <- apply(grid, 1, paste, collapse = \"\")\n    index1 <- match(a1.vec, a2.vec)\n\n  #  indices <- which(is.na(match(data.frame(t(signatures)), data.frame(t(grid))))\n  #  vec <- vec[match(data.frame(t(signatures)), data.frame(t(grid)))]\n  #  vec[is.na(vec)] <- 1e-20\n  #  vec <- vec/sum(vec);\n    new_theta[,k] <-  vec[index1]/(sum(vec[index1]))\n  }\n  new_theta_2 <- matrix(0, dim(theta_old)[1], dim(theta_old)[2])\n  new_theta_2[ind_model_indices, ] <- new_theta\n  if(length(ind_model_indices) < dim(theta_old)[1]){\n    new_theta_2[-ind_model_indices, ] <- theta1\n  }\n  new_theta_2 <- apply(new_theta_2, 2, function(x) return(x/sum(x)))\n  rownames(new_theta_2) <- rownames(theta_old)\n  ll <- list(\"f_array\" = f_array, \"theta\" = new_theta_2)\n  return(ll)\n}\n\n# library(compare)\n# out <- compare(data.frame(signatures), data.frame(grid), allowAll = TRUE)\n#\n#\n# a1 <- data.frame(a = 1:5, b = letters[1:5])\n# a2 <- data.frame(a = 1:3, b = letters[1:3])\n# comparison <- compare(a1,a2,allowAll=TRUE)\n",
    "created" : 1504633059853.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2573960675",
    "id" : "4C001A31",
    "lastKnownWriteTime" : 1484699454,
    "last_content_update" : 1484699454,
    "path" : "~/Documents/covtpx/R/tpx.R",
    "project_path" : "R/tpx.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}